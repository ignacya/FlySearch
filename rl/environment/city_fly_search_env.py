from time import sleep
from typing import Dict

from glimpse_generators.unreal_client_wrapper import UnrealClientWrapper
from misc.unreal_utils import get_city_env_binary
from rl.environment.base_fly_search_env import BaseFlySearchEnv, DroneCannotSeeTargetException, \
    ObjectInBuildingException, ObjectBadPlacementException
from scenarios.object_classes.base_object_class import BaseObjectClass
from scenarios.object_classes.forest_sun_class import SunClass
from scenarios.object_classes.pcg_class import PCGClass


class CityFlySearchEnv(BaseFlySearchEnv):
    def __init__(self, resolution: int = 500, max_altitude: int = 120, throw_if_hard_config: bool = True,
                 give_class_image: bool = False):
        super().__init__(resolution=resolution, max_altitude=max_altitude, throw_if_hard_config=throw_if_hard_config,
                         give_class_image=give_class_image)

    def get_client(self) -> UnrealClientWrapper:
        city_binary_path = get_city_env_binary()

        return UnrealClientWrapper(host="localhost", port=9000, unreal_binary_path=city_binary_path)

    def _configure(self, options: Dict) -> None:
        if "object_coords" in options:
            self.load_map(*options["object_coords"], *options["drone_rel_coords"])

        if "set_object" in options and options["set_object"]:
            seed = options["seed"]

            object_type: BaseObjectClass = options["object_type"]
            object_class = self.classes_to_ids[object_type]

            self.hide_all_movable_objects()

            object_id = object_class.move_and_show(*options["object_coords"], seed)
            options["object_id"] = object_id

            if "object_rot" in options:
                object_class.rotate_object(object_id, *options["object_rot"])

            # NOTE: We assume that things generated by the city generator won't occlude the target

            if self.throw_if_hard_config:
                can_see = "true" in self.glimpse_generator.client.request(f"vget /camera/1/cansee {object_id}")
                if not can_see:
                    raise DroneCannotSeeTargetException(
                        "Object is not visible from the drone position as required by config"
                    )
            else:
                camera_unreal_coordinates = self.glimpse_generator.get_unreal_camera_coordinates()
                camera_unreal_coordinates = list(camera_unreal_coordinates)
                camera_unreal_coordinates[2] = 500 * 100.0
                cansee_points_coord_str = ":".join(map(str, camera_unreal_coordinates))

                points_count = int(self.glimpse_generator.client.request(
                    f"vget /camera/1/cansee_points {cansee_points_coord_str}"))

                in_building = (points_count == 0)

                if in_building:
                    raise ObjectInBuildingException("Object is inside a building")

                object_unreal_coordinates = options["object_coords"]
                object_unreal_coordinates = list(object_unreal_coordinates)
                object_unreal_coordinates[2] = 500 * 100.0
                cansee_points_coord_str = ":".join(map(str, object_unreal_coordinates))

                points_count = int(self.glimpse_generator.client.request(
                    f"vget /object/{object_id}/cansee_points {cansee_points_coord_str}"
                ))
                weird_object_placement = (points_count == 0)

                if weird_object_placement:
                    raise ObjectBadPlacementException("Object has a bad placement (e.g. inside a wall)")

            city_generator_class: PCGClass = self.classes_to_ids["CITY"]
            city_generator_class.move_and_show(*options["object_coords"], seed)

        if "sun_y" in options and "sun_z" in options:
            sun_y = options["sun_y"]
            sun_z = options["sun_z"]
            sun_class: SunClass = self.classes_to_ids["CITY_SUN"]
            sun_class.set_sun_rotation(sun_y, sun_z)

        if 'FIRE' in str(options["object_type"]):
            sleep(10)  # Wait for the fire to start burning -- in case it's needed
        else:
            sleep(5)  # wait for the objects to load
